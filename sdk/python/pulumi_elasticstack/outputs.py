# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ElasticsearchClusterSettingsElasticsearchConnection',
    'ElasticsearchClusterSettingsPersistent',
    'ElasticsearchClusterSettingsPersistentSetting',
    'ElasticsearchClusterSettingsTransient',
    'ElasticsearchClusterSettingsTransientSetting',
    'ElasticsearchComponentTemplateElasticsearchConnection',
    'ElasticsearchComponentTemplateTemplate',
    'ElasticsearchComponentTemplateTemplateAlias',
    'ElasticsearchDataStreamElasticsearchConnection',
    'ElasticsearchDataStreamIndex',
    'ElasticsearchIndexAlias',
    'ElasticsearchIndexElasticsearchConnection',
    'ElasticsearchIndexLifecycleCold',
    'ElasticsearchIndexLifecycleColdAllocate',
    'ElasticsearchIndexLifecycleColdFreeze',
    'ElasticsearchIndexLifecycleColdMigrate',
    'ElasticsearchIndexLifecycleColdReadonly',
    'ElasticsearchIndexLifecycleColdSearchableSnapshot',
    'ElasticsearchIndexLifecycleColdSetPriority',
    'ElasticsearchIndexLifecycleColdUnfollow',
    'ElasticsearchIndexLifecycleDelete',
    'ElasticsearchIndexLifecycleDeleteDelete',
    'ElasticsearchIndexLifecycleDeleteWaitForSnapshot',
    'ElasticsearchIndexLifecycleElasticsearchConnection',
    'ElasticsearchIndexLifecycleFrozen',
    'ElasticsearchIndexLifecycleFrozenSearchableSnapshot',
    'ElasticsearchIndexLifecycleHot',
    'ElasticsearchIndexLifecycleHotForcemerge',
    'ElasticsearchIndexLifecycleHotReadonly',
    'ElasticsearchIndexLifecycleHotRollover',
    'ElasticsearchIndexLifecycleHotSearchableSnapshot',
    'ElasticsearchIndexLifecycleHotSetPriority',
    'ElasticsearchIndexLifecycleHotShrink',
    'ElasticsearchIndexLifecycleHotUnfollow',
    'ElasticsearchIndexLifecycleWarm',
    'ElasticsearchIndexLifecycleWarmAllocate',
    'ElasticsearchIndexLifecycleWarmForcemerge',
    'ElasticsearchIndexLifecycleWarmMigrate',
    'ElasticsearchIndexLifecycleWarmReadonly',
    'ElasticsearchIndexLifecycleWarmSetPriority',
    'ElasticsearchIndexLifecycleWarmShrink',
    'ElasticsearchIndexLifecycleWarmUnfollow',
    'ElasticsearchIndexSettings',
    'ElasticsearchIndexSettingsSetting',
    'ElasticsearchIndexTemplateDataStream',
    'ElasticsearchIndexTemplateElasticsearchConnection',
    'ElasticsearchIndexTemplateTemplate',
    'ElasticsearchIndexTemplateTemplateAlias',
    'ElasticsearchIngestPipelineElasticsearchConnection',
    'ElasticsearchSecurityRoleApplication',
    'ElasticsearchSecurityRoleElasticsearchConnection',
    'ElasticsearchSecurityRoleIndex',
    'ElasticsearchSecurityRoleIndexFieldSecurity',
    'ElasticsearchSecurityUserElasticsearchConnection',
    'ElasticsearchSnapshotLifecycleElasticsearchConnection',
    'ElasticsearchSnapshotRepositoryAzure',
    'ElasticsearchSnapshotRepositoryElasticsearchConnection',
    'ElasticsearchSnapshotRepositoryFs',
    'ElasticsearchSnapshotRepositoryGcs',
    'ElasticsearchSnapshotRepositoryHdfs',
    'ElasticsearchSnapshotRepositoryS3',
    'ElasticsearchSnapshotRepositoryUrl',
]

@pulumi.output_type
class ElasticsearchClusterSettingsElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchClusterSettingsElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchClusterSettingsElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchClusterSettingsElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchClusterSettingsPersistent(dict):
    def __init__(__self__, *,
                 settings: Sequence['outputs.ElasticsearchClusterSettingsPersistentSetting']):
        """
        :param Sequence['ElasticsearchClusterSettingsPersistentSettingArgs'] settings: Defines the setting in the cluster.
        """
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> Sequence['outputs.ElasticsearchClusterSettingsPersistentSetting']:
        """
        Defines the setting in the cluster.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ElasticsearchClusterSettingsPersistentSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueLists":
            suggest = "value_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchClusterSettingsPersistentSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchClusterSettingsPersistentSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchClusterSettingsPersistentSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_lists: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "value_lists")


@pulumi.output_type
class ElasticsearchClusterSettingsTransient(dict):
    def __init__(__self__, *,
                 settings: Sequence['outputs.ElasticsearchClusterSettingsTransientSetting']):
        """
        :param Sequence['ElasticsearchClusterSettingsTransientSettingArgs'] settings: Defines the setting in the cluster.
        """
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> Sequence['outputs.ElasticsearchClusterSettingsTransientSetting']:
        """
        Defines the setting in the cluster.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ElasticsearchClusterSettingsTransientSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueLists":
            suggest = "value_lists"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchClusterSettingsTransientSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchClusterSettingsTransientSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchClusterSettingsTransientSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_lists: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "value_lists")


@pulumi.output_type
class ElasticsearchComponentTemplateElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchComponentTemplateElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchComponentTemplateElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchComponentTemplateElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchComponentTemplateTemplate(dict):
    def __init__(__self__, *,
                 aliases: Optional[Sequence['outputs.ElasticsearchComponentTemplateTemplateAlias']] = None,
                 mappings: Optional[str] = None,
                 settings: Optional[str] = None):
        """
        :param Sequence['ElasticsearchComponentTemplateTemplateAliasArgs'] aliases: Alias to add.
        :param str mappings: Mapping for fields in the index.
        :param str settings: Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence['outputs.ElasticsearchComponentTemplateTemplateAlias']]:
        """
        Alias to add.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[str]:
        """
        Mapping for fields in the index.
        """
        return pulumi.get(self, "mappings")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ElasticsearchComponentTemplateTemplateAlias(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexRouting":
            suggest = "index_routing"
        elif key == "isHidden":
            suggest = "is_hidden"
        elif key == "isWriteIndex":
            suggest = "is_write_index"
        elif key == "searchRouting":
            suggest = "search_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchComponentTemplateTemplateAlias. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchComponentTemplateTemplateAlias.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchComponentTemplateTemplateAlias.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 filter: Optional[str] = None,
                 index_routing: Optional[str] = None,
                 is_hidden: Optional[bool] = None,
                 is_write_index: Optional[bool] = None,
                 routing: Optional[str] = None,
                 search_routing: Optional[str] = None):
        """
        :param str name: Name of the component template to create.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if index_routing is not None:
            pulumi.set(__self__, "index_routing", index_routing)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_write_index is not None:
            pulumi.set(__self__, "is_write_index", is_write_index)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)
        if search_routing is not None:
            pulumi.set(__self__, "search_routing", search_routing)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the component template to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="indexRouting")
    def index_routing(self) -> Optional[str]:
        return pulumi.get(self, "index_routing")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter(name="isWriteIndex")
    def is_write_index(self) -> Optional[bool]:
        return pulumi.get(self, "is_write_index")

    @property
    @pulumi.getter
    def routing(self) -> Optional[str]:
        return pulumi.get(self, "routing")

    @property
    @pulumi.getter(name="searchRouting")
    def search_routing(self) -> Optional[str]:
        return pulumi.get(self, "search_routing")


@pulumi.output_type
class ElasticsearchDataStreamElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchDataStreamElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchDataStreamElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchDataStreamElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchDataStreamIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexName":
            suggest = "index_name"
        elif key == "indexUuid":
            suggest = "index_uuid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchDataStreamIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchDataStreamIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchDataStreamIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index_name: Optional[str] = None,
                 index_uuid: Optional[str] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if index_uuid is not None:
            pulumi.set(__self__, "index_uuid", index_uuid)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[str]:
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="indexUuid")
    def index_uuid(self) -> Optional[str]:
        return pulumi.get(self, "index_uuid")


@pulumi.output_type
class ElasticsearchIndexAlias(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexRouting":
            suggest = "index_routing"
        elif key == "isHidden":
            suggest = "is_hidden"
        elif key == "isWriteIndex":
            suggest = "is_write_index"
        elif key == "searchRouting":
            suggest = "search_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexAlias. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexAlias.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexAlias.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 filter: Optional[str] = None,
                 index_routing: Optional[str] = None,
                 is_hidden: Optional[bool] = None,
                 is_write_index: Optional[bool] = None,
                 routing: Optional[str] = None,
                 search_routing: Optional[str] = None):
        """
        :param str name: Index alias name.
        :param str filter: Query used to limit documents the alias can access.
        :param str index_routing: Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
        :param bool is_hidden: If true, the alias is hidden.
        :param bool is_write_index: If true, the index is the write index for the alias.
        :param str routing: Value used to route indexing and search operations to a specific shard.
        :param str search_routing: Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if index_routing is not None:
            pulumi.set(__self__, "index_routing", index_routing)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_write_index is not None:
            pulumi.set(__self__, "is_write_index", is_write_index)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)
        if search_routing is not None:
            pulumi.set(__self__, "search_routing", search_routing)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Index alias name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        Query used to limit documents the alias can access.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="indexRouting")
    def index_routing(self) -> Optional[str]:
        """
        Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
        """
        return pulumi.get(self, "index_routing")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        If true, the alias is hidden.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter(name="isWriteIndex")
    def is_write_index(self) -> Optional[bool]:
        """
        If true, the index is the write index for the alias.
        """
        return pulumi.get(self, "is_write_index")

    @property
    @pulumi.getter
    def routing(self) -> Optional[str]:
        """
        Value used to route indexing and search operations to a specific shard.
        """
        return pulumi.get(self, "routing")

    @property
    @pulumi.getter(name="searchRouting")
    def search_routing(self) -> Optional[str]:
        """
        Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
        """
        return pulumi.get(self, "search_routing")


@pulumi.output_type
class ElasticsearchIndexElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchIndexLifecycleCold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minAge":
            suggest = "min_age"
        elif key == "searchableSnapshot":
            suggest = "searchable_snapshot"
        elif key == "setPriority":
            suggest = "set_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleCold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleCold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleCold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocate: Optional['outputs.ElasticsearchIndexLifecycleColdAllocate'] = None,
                 freeze: Optional['outputs.ElasticsearchIndexLifecycleColdFreeze'] = None,
                 migrate: Optional['outputs.ElasticsearchIndexLifecycleColdMigrate'] = None,
                 min_age: Optional[str] = None,
                 readonly: Optional['outputs.ElasticsearchIndexLifecycleColdReadonly'] = None,
                 searchable_snapshot: Optional['outputs.ElasticsearchIndexLifecycleColdSearchableSnapshot'] = None,
                 set_priority: Optional['outputs.ElasticsearchIndexLifecycleColdSetPriority'] = None,
                 unfollow: Optional['outputs.ElasticsearchIndexLifecycleColdUnfollow'] = None):
        """
        :param 'ElasticsearchIndexLifecycleColdAllocateArgs' allocate: Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        :param 'ElasticsearchIndexLifecycleColdFreezeArgs' freeze: Freeze the index to minimize its memory footprint.
        :param 'ElasticsearchIndexLifecycleColdMigrateArgs' migrate: Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        :param str min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param 'ElasticsearchIndexLifecycleColdReadonlyArgs' readonly: Makes the index read-only.
        :param 'ElasticsearchIndexLifecycleColdSearchableSnapshotArgs' searchable_snapshot: Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        :param 'ElasticsearchIndexLifecycleColdSetPriorityArgs' set_priority: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param 'ElasticsearchIndexLifecycleColdUnfollowArgs' unfollow: Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        if allocate is not None:
            pulumi.set(__self__, "allocate", allocate)
        if freeze is not None:
            pulumi.set(__self__, "freeze", freeze)
        if migrate is not None:
            pulumi.set(__self__, "migrate", migrate)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if searchable_snapshot is not None:
            pulumi.set(__self__, "searchable_snapshot", searchable_snapshot)
        if set_priority is not None:
            pulumi.set(__self__, "set_priority", set_priority)
        if unfollow is not None:
            pulumi.set(__self__, "unfollow", unfollow)

    @property
    @pulumi.getter
    def allocate(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdAllocate']:
        """
        Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        """
        return pulumi.get(self, "allocate")

    @property
    @pulumi.getter
    def freeze(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdFreeze']:
        """
        Freeze the index to minimize its memory footprint.
        """
        return pulumi.get(self, "freeze")

    @property
    @pulumi.getter
    def migrate(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdMigrate']:
        """
        Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        """
        return pulumi.get(self, "migrate")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @property
    @pulumi.getter
    def readonly(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdReadonly']:
        """
        Makes the index read-only.
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter(name="searchableSnapshot")
    def searchable_snapshot(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdSearchableSnapshot']:
        """
        Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        return pulumi.get(self, "searchable_snapshot")

    @property
    @pulumi.getter(name="setPriority")
    def set_priority(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdSetPriority']:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "set_priority")

    @property
    @pulumi.getter
    def unfollow(self) -> Optional['outputs.ElasticsearchIndexLifecycleColdUnfollow']:
        """
        Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        return pulumi.get(self, "unfollow")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdAllocate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfReplicas":
            suggest = "number_of_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleColdAllocate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleColdAllocate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleColdAllocate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude: Optional[str] = None,
                 include: Optional[str] = None,
                 number_of_replicas: Optional[int] = None,
                 require: Optional[str] = None):
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if require is not None:
            pulumi.set(__self__, "require", require)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[str]:
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter
    def include(self) -> Optional[str]:
        return pulumi.get(self, "include")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter
    def require(self) -> Optional[str]:
        return pulumi.get(self, "require")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdFreeze(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdMigrate(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdReadonly(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdSearchableSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotRepository":
            suggest = "snapshot_repository"
        elif key == "forceMergeIndex":
            suggest = "force_merge_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleColdSearchableSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleColdSearchableSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleColdSearchableSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_repository: str,
                 force_merge_index: Optional[bool] = None):
        pulumi.set(__self__, "snapshot_repository", snapshot_repository)
        if force_merge_index is not None:
            pulumi.set(__self__, "force_merge_index", force_merge_index)

    @property
    @pulumi.getter(name="snapshotRepository")
    def snapshot_repository(self) -> str:
        return pulumi.get(self, "snapshot_repository")

    @property
    @pulumi.getter(name="forceMergeIndex")
    def force_merge_index(self) -> Optional[bool]:
        return pulumi.get(self, "force_merge_index")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdSetPriority(dict):
    def __init__(__self__, *,
                 priority: int):
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")


@pulumi.output_type
class ElasticsearchIndexLifecycleColdUnfollow(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleDelete(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minAge":
            suggest = "min_age"
        elif key == "waitForSnapshot":
            suggest = "wait_for_snapshot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleDelete. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleDelete.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleDelete.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete: Optional['outputs.ElasticsearchIndexLifecycleDeleteDelete'] = None,
                 min_age: Optional[str] = None,
                 wait_for_snapshot: Optional['outputs.ElasticsearchIndexLifecycleDeleteWaitForSnapshot'] = None):
        """
        :param 'ElasticsearchIndexLifecycleDeleteDeleteArgs' delete: Permanently removes the index.
        :param str min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param 'ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs' wait_for_snapshot: Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if wait_for_snapshot is not None:
            pulumi.set(__self__, "wait_for_snapshot", wait_for_snapshot)

    @property
    @pulumi.getter
    def delete(self) -> Optional['outputs.ElasticsearchIndexLifecycleDeleteDelete']:
        """
        Permanently removes the index.
        """
        return pulumi.get(self, "delete")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @property
    @pulumi.getter(name="waitForSnapshot")
    def wait_for_snapshot(self) -> Optional['outputs.ElasticsearchIndexLifecycleDeleteWaitForSnapshot']:
        """
        Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.
        """
        return pulumi.get(self, "wait_for_snapshot")


@pulumi.output_type
class ElasticsearchIndexLifecycleDeleteDelete(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deleteSearchableSnapshot":
            suggest = "delete_searchable_snapshot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleDeleteDelete. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleDeleteDelete.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleDeleteDelete.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 delete_searchable_snapshot: Optional[bool] = None):
        if delete_searchable_snapshot is not None:
            pulumi.set(__self__, "delete_searchable_snapshot", delete_searchable_snapshot)

    @property
    @pulumi.getter(name="deleteSearchableSnapshot")
    def delete_searchable_snapshot(self) -> Optional[bool]:
        return pulumi.get(self, "delete_searchable_snapshot")


@pulumi.output_type
class ElasticsearchIndexLifecycleDeleteWaitForSnapshot(dict):
    def __init__(__self__, *,
                 policy: str):
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> str:
        return pulumi.get(self, "policy")


@pulumi.output_type
class ElasticsearchIndexLifecycleElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchIndexLifecycleFrozen(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minAge":
            suggest = "min_age"
        elif key == "searchableSnapshot":
            suggest = "searchable_snapshot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleFrozen. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleFrozen.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleFrozen.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_age: Optional[str] = None,
                 searchable_snapshot: Optional['outputs.ElasticsearchIndexLifecycleFrozenSearchableSnapshot'] = None):
        """
        :param str min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param 'ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs' searchable_snapshot: Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if searchable_snapshot is not None:
            pulumi.set(__self__, "searchable_snapshot", searchable_snapshot)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @property
    @pulumi.getter(name="searchableSnapshot")
    def searchable_snapshot(self) -> Optional['outputs.ElasticsearchIndexLifecycleFrozenSearchableSnapshot']:
        """
        Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        return pulumi.get(self, "searchable_snapshot")


@pulumi.output_type
class ElasticsearchIndexLifecycleFrozenSearchableSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotRepository":
            suggest = "snapshot_repository"
        elif key == "forceMergeIndex":
            suggest = "force_merge_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleFrozenSearchableSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleFrozenSearchableSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleFrozenSearchableSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_repository: str,
                 force_merge_index: Optional[bool] = None):
        pulumi.set(__self__, "snapshot_repository", snapshot_repository)
        if force_merge_index is not None:
            pulumi.set(__self__, "force_merge_index", force_merge_index)

    @property
    @pulumi.getter(name="snapshotRepository")
    def snapshot_repository(self) -> str:
        return pulumi.get(self, "snapshot_repository")

    @property
    @pulumi.getter(name="forceMergeIndex")
    def force_merge_index(self) -> Optional[bool]:
        return pulumi.get(self, "force_merge_index")


@pulumi.output_type
class ElasticsearchIndexLifecycleHot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minAge":
            suggest = "min_age"
        elif key == "searchableSnapshot":
            suggest = "searchable_snapshot"
        elif key == "setPriority":
            suggest = "set_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleHot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleHot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleHot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forcemerge: Optional['outputs.ElasticsearchIndexLifecycleHotForcemerge'] = None,
                 min_age: Optional[str] = None,
                 readonly: Optional['outputs.ElasticsearchIndexLifecycleHotReadonly'] = None,
                 rollover: Optional['outputs.ElasticsearchIndexLifecycleHotRollover'] = None,
                 searchable_snapshot: Optional['outputs.ElasticsearchIndexLifecycleHotSearchableSnapshot'] = None,
                 set_priority: Optional['outputs.ElasticsearchIndexLifecycleHotSetPriority'] = None,
                 shrink: Optional['outputs.ElasticsearchIndexLifecycleHotShrink'] = None,
                 unfollow: Optional['outputs.ElasticsearchIndexLifecycleHotUnfollow'] = None):
        """
        :param 'ElasticsearchIndexLifecycleHotForcemergeArgs' forcemerge: Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        :param str min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param 'ElasticsearchIndexLifecycleHotReadonlyArgs' readonly: Makes the index read-only.
        :param 'ElasticsearchIndexLifecycleHotRolloverArgs' rollover: Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.
        :param 'ElasticsearchIndexLifecycleHotSearchableSnapshotArgs' searchable_snapshot: Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        :param 'ElasticsearchIndexLifecycleHotSetPriorityArgs' set_priority: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param 'ElasticsearchIndexLifecycleHotShrinkArgs' shrink: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param 'ElasticsearchIndexLifecycleHotUnfollowArgs' unfollow: Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        if forcemerge is not None:
            pulumi.set(__self__, "forcemerge", forcemerge)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if rollover is not None:
            pulumi.set(__self__, "rollover", rollover)
        if searchable_snapshot is not None:
            pulumi.set(__self__, "searchable_snapshot", searchable_snapshot)
        if set_priority is not None:
            pulumi.set(__self__, "set_priority", set_priority)
        if shrink is not None:
            pulumi.set(__self__, "shrink", shrink)
        if unfollow is not None:
            pulumi.set(__self__, "unfollow", unfollow)

    @property
    @pulumi.getter
    def forcemerge(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotForcemerge']:
        """
        Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        """
        return pulumi.get(self, "forcemerge")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @property
    @pulumi.getter
    def readonly(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotReadonly']:
        """
        Makes the index read-only.
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter
    def rollover(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotRollover']:
        """
        Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.
        """
        return pulumi.get(self, "rollover")

    @property
    @pulumi.getter(name="searchableSnapshot")
    def searchable_snapshot(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotSearchableSnapshot']:
        """
        Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        return pulumi.get(self, "searchable_snapshot")

    @property
    @pulumi.getter(name="setPriority")
    def set_priority(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotSetPriority']:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "set_priority")

    @property
    @pulumi.getter
    def shrink(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotShrink']:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "shrink")

    @property
    @pulumi.getter
    def unfollow(self) -> Optional['outputs.ElasticsearchIndexLifecycleHotUnfollow']:
        """
        Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        return pulumi.get(self, "unfollow")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotForcemerge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNumSegments":
            suggest = "max_num_segments"
        elif key == "indexCodec":
            suggest = "index_codec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleHotForcemerge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleHotForcemerge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleHotForcemerge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_num_segments: int,
                 index_codec: Optional[str] = None):
        pulumi.set(__self__, "max_num_segments", max_num_segments)
        if index_codec is not None:
            pulumi.set(__self__, "index_codec", index_codec)

    @property
    @pulumi.getter(name="maxNumSegments")
    def max_num_segments(self) -> int:
        return pulumi.get(self, "max_num_segments")

    @property
    @pulumi.getter(name="indexCodec")
    def index_codec(self) -> Optional[str]:
        return pulumi.get(self, "index_codec")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotReadonly(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotRollover(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxAge":
            suggest = "max_age"
        elif key == "maxDocs":
            suggest = "max_docs"
        elif key == "maxPrimaryShardSize":
            suggest = "max_primary_shard_size"
        elif key == "maxSize":
            suggest = "max_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleHotRollover. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleHotRollover.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleHotRollover.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_age: Optional[str] = None,
                 max_docs: Optional[int] = None,
                 max_primary_shard_size: Optional[str] = None,
                 max_size: Optional[str] = None):
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_docs is not None:
            pulumi.set(__self__, "max_docs", max_docs)
        if max_primary_shard_size is not None:
            pulumi.set(__self__, "max_primary_shard_size", max_primary_shard_size)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[str]:
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="maxDocs")
    def max_docs(self) -> Optional[int]:
        return pulumi.get(self, "max_docs")

    @property
    @pulumi.getter(name="maxPrimaryShardSize")
    def max_primary_shard_size(self) -> Optional[str]:
        return pulumi.get(self, "max_primary_shard_size")

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[str]:
        return pulumi.get(self, "max_size")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotSearchableSnapshot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snapshotRepository":
            suggest = "snapshot_repository"
        elif key == "forceMergeIndex":
            suggest = "force_merge_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleHotSearchableSnapshot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleHotSearchableSnapshot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleHotSearchableSnapshot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 snapshot_repository: str,
                 force_merge_index: Optional[bool] = None):
        pulumi.set(__self__, "snapshot_repository", snapshot_repository)
        if force_merge_index is not None:
            pulumi.set(__self__, "force_merge_index", force_merge_index)

    @property
    @pulumi.getter(name="snapshotRepository")
    def snapshot_repository(self) -> str:
        return pulumi.get(self, "snapshot_repository")

    @property
    @pulumi.getter(name="forceMergeIndex")
    def force_merge_index(self) -> Optional[bool]:
        return pulumi.get(self, "force_merge_index")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotSetPriority(dict):
    def __init__(__self__, *,
                 priority: int):
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotShrink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPrimaryShardSize":
            suggest = "max_primary_shard_size"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleHotShrink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleHotShrink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleHotShrink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_primary_shard_size: Optional[str] = None,
                 number_of_shards: Optional[int] = None):
        if max_primary_shard_size is not None:
            pulumi.set(__self__, "max_primary_shard_size", max_primary_shard_size)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="maxPrimaryShardSize")
    def max_primary_shard_size(self) -> Optional[str]:
        return pulumi.get(self, "max_primary_shard_size")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class ElasticsearchIndexLifecycleHotUnfollow(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minAge":
            suggest = "min_age"
        elif key == "setPriority":
            suggest = "set_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleWarm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleWarm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleWarm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allocate: Optional['outputs.ElasticsearchIndexLifecycleWarmAllocate'] = None,
                 forcemerge: Optional['outputs.ElasticsearchIndexLifecycleWarmForcemerge'] = None,
                 migrate: Optional['outputs.ElasticsearchIndexLifecycleWarmMigrate'] = None,
                 min_age: Optional[str] = None,
                 readonly: Optional['outputs.ElasticsearchIndexLifecycleWarmReadonly'] = None,
                 set_priority: Optional['outputs.ElasticsearchIndexLifecycleWarmSetPriority'] = None,
                 shrink: Optional['outputs.ElasticsearchIndexLifecycleWarmShrink'] = None,
                 unfollow: Optional['outputs.ElasticsearchIndexLifecycleWarmUnfollow'] = None):
        """
        :param 'ElasticsearchIndexLifecycleWarmAllocateArgs' allocate: Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        :param 'ElasticsearchIndexLifecycleWarmForcemergeArgs' forcemerge: Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        :param 'ElasticsearchIndexLifecycleWarmMigrateArgs' migrate: Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        :param str min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param 'ElasticsearchIndexLifecycleWarmReadonlyArgs' readonly: Makes the index read-only.
        :param 'ElasticsearchIndexLifecycleWarmSetPriorityArgs' set_priority: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param 'ElasticsearchIndexLifecycleWarmShrinkArgs' shrink: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param 'ElasticsearchIndexLifecycleWarmUnfollowArgs' unfollow: Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        if allocate is not None:
            pulumi.set(__self__, "allocate", allocate)
        if forcemerge is not None:
            pulumi.set(__self__, "forcemerge", forcemerge)
        if migrate is not None:
            pulumi.set(__self__, "migrate", migrate)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if set_priority is not None:
            pulumi.set(__self__, "set_priority", set_priority)
        if shrink is not None:
            pulumi.set(__self__, "shrink", shrink)
        if unfollow is not None:
            pulumi.set(__self__, "unfollow", unfollow)

    @property
    @pulumi.getter
    def allocate(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmAllocate']:
        """
        Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        """
        return pulumi.get(self, "allocate")

    @property
    @pulumi.getter
    def forcemerge(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmForcemerge']:
        """
        Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        """
        return pulumi.get(self, "forcemerge")

    @property
    @pulumi.getter
    def migrate(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmMigrate']:
        """
        Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        """
        return pulumi.get(self, "migrate")

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[str]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @property
    @pulumi.getter
    def readonly(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmReadonly']:
        """
        Makes the index read-only.
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter(name="setPriority")
    def set_priority(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmSetPriority']:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "set_priority")

    @property
    @pulumi.getter
    def shrink(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmShrink']:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "shrink")

    @property
    @pulumi.getter
    def unfollow(self) -> Optional['outputs.ElasticsearchIndexLifecycleWarmUnfollow']:
        """
        Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        return pulumi.get(self, "unfollow")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmAllocate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfReplicas":
            suggest = "number_of_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleWarmAllocate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleWarmAllocate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleWarmAllocate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude: Optional[str] = None,
                 include: Optional[str] = None,
                 number_of_replicas: Optional[int] = None,
                 require: Optional[str] = None):
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if require is not None:
            pulumi.set(__self__, "require", require)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[str]:
        return pulumi.get(self, "exclude")

    @property
    @pulumi.getter
    def include(self) -> Optional[str]:
        return pulumi.get(self, "include")

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[int]:
        return pulumi.get(self, "number_of_replicas")

    @property
    @pulumi.getter
    def require(self) -> Optional[str]:
        return pulumi.get(self, "require")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmForcemerge(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxNumSegments":
            suggest = "max_num_segments"
        elif key == "indexCodec":
            suggest = "index_codec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleWarmForcemerge. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleWarmForcemerge.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleWarmForcemerge.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_num_segments: int,
                 index_codec: Optional[str] = None):
        pulumi.set(__self__, "max_num_segments", max_num_segments)
        if index_codec is not None:
            pulumi.set(__self__, "index_codec", index_codec)

    @property
    @pulumi.getter(name="maxNumSegments")
    def max_num_segments(self) -> int:
        return pulumi.get(self, "max_num_segments")

    @property
    @pulumi.getter(name="indexCodec")
    def index_codec(self) -> Optional[str]:
        return pulumi.get(self, "index_codec")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmMigrate(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmReadonly(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmSetPriority(dict):
    def __init__(__self__, *,
                 priority: int):
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> int:
        return pulumi.get(self, "priority")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmShrink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPrimaryShardSize":
            suggest = "max_primary_shard_size"
        elif key == "numberOfShards":
            suggest = "number_of_shards"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexLifecycleWarmShrink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexLifecycleWarmShrink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexLifecycleWarmShrink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_primary_shard_size: Optional[str] = None,
                 number_of_shards: Optional[int] = None):
        if max_primary_shard_size is not None:
            pulumi.set(__self__, "max_primary_shard_size", max_primary_shard_size)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="maxPrimaryShardSize")
    def max_primary_shard_size(self) -> Optional[str]:
        return pulumi.get(self, "max_primary_shard_size")

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[int]:
        return pulumi.get(self, "number_of_shards")


@pulumi.output_type
class ElasticsearchIndexLifecycleWarmUnfollow(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ElasticsearchIndexSettings(dict):
    def __init__(__self__, *,
                 settings: Sequence['outputs.ElasticsearchIndexSettingsSetting']):
        """
        :param Sequence['ElasticsearchIndexSettingsSettingArgs'] settings: Defines the setting for the index.
        """
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> Sequence['outputs.ElasticsearchIndexSettingsSetting']:
        """
        Defines the setting for the index.
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ElasticsearchIndexSettingsSetting(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the index you wish to create.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index you wish to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class ElasticsearchIndexTemplateDataStream(dict):
    def __init__(__self__, *,
                 hidden: Optional[bool] = None):
        """
        :param bool hidden: If true, the data stream is hidden.
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[bool]:
        """
        If true, the data stream is hidden.
        """
        return pulumi.get(self, "hidden")


@pulumi.output_type
class ElasticsearchIndexTemplateElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexTemplateElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexTemplateElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexTemplateElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchIndexTemplateTemplate(dict):
    def __init__(__self__, *,
                 aliases: Optional[Sequence['outputs.ElasticsearchIndexTemplateTemplateAlias']] = None,
                 mappings: Optional[str] = None,
                 settings: Optional[str] = None):
        """
        :param Sequence['ElasticsearchIndexTemplateTemplateAliasArgs'] aliases: Alias to add.
        :param str mappings: Mapping for fields in the index.
        :param str settings: Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[Sequence['outputs.ElasticsearchIndexTemplateTemplateAlias']]:
        """
        Alias to add.
        """
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[str]:
        """
        Mapping for fields in the index.
        """
        return pulumi.get(self, "mappings")

    @property
    @pulumi.getter
    def settings(self) -> Optional[str]:
        """
        Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        return pulumi.get(self, "settings")


@pulumi.output_type
class ElasticsearchIndexTemplateTemplateAlias(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "indexRouting":
            suggest = "index_routing"
        elif key == "isHidden":
            suggest = "is_hidden"
        elif key == "isWriteIndex":
            suggest = "is_write_index"
        elif key == "searchRouting":
            suggest = "search_routing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIndexTemplateTemplateAlias. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIndexTemplateTemplateAlias.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIndexTemplateTemplateAlias.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 filter: Optional[str] = None,
                 index_routing: Optional[str] = None,
                 is_hidden: Optional[bool] = None,
                 is_write_index: Optional[bool] = None,
                 routing: Optional[str] = None,
                 search_routing: Optional[str] = None):
        """
        :param str name: Name of the index template to create.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if index_routing is not None:
            pulumi.set(__self__, "index_routing", index_routing)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_write_index is not None:
            pulumi.set(__self__, "is_write_index", is_write_index)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)
        if search_routing is not None:
            pulumi.set(__self__, "search_routing", search_routing)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the index template to create.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="indexRouting")
    def index_routing(self) -> Optional[str]:
        return pulumi.get(self, "index_routing")

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter(name="isWriteIndex")
    def is_write_index(self) -> Optional[bool]:
        return pulumi.get(self, "is_write_index")

    @property
    @pulumi.getter
    def routing(self) -> Optional[str]:
        return pulumi.get(self, "routing")

    @property
    @pulumi.getter(name="searchRouting")
    def search_routing(self) -> Optional[str]:
        return pulumi.get(self, "search_routing")


@pulumi.output_type
class ElasticsearchIngestPipelineElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchIngestPipelineElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchIngestPipelineElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchIngestPipelineElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchSecurityRoleApplication(dict):
    def __init__(__self__, *,
                 application: str,
                 privileges: Sequence[str],
                 resources: Sequence[str]):
        """
        :param str application: The name of the application to which this entry applies.
        :param Sequence[str] privileges: A list of strings, where each element is the name of an application privilege or action.
        :param Sequence[str] resources: A list resources to which the privileges are applied.
        """
        pulumi.set(__self__, "application", application)
        pulumi.set(__self__, "privileges", privileges)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def application(self) -> str:
        """
        The name of the application to which this entry applies.
        """
        return pulumi.get(self, "application")

    @property
    @pulumi.getter
    def privileges(self) -> Sequence[str]:
        """
        A list of strings, where each element is the name of an application privilege or action.
        """
        return pulumi.get(self, "privileges")

    @property
    @pulumi.getter
    def resources(self) -> Sequence[str]:
        """
        A list resources to which the privileges are applied.
        """
        return pulumi.get(self, "resources")


@pulumi.output_type
class ElasticsearchSecurityRoleElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSecurityRoleElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSecurityRoleElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSecurityRoleElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchSecurityRoleIndex(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldSecurity":
            suggest = "field_security"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSecurityRoleIndex. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSecurityRoleIndex.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSecurityRoleIndex.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 names: Sequence[str],
                 privileges: Sequence[str],
                 field_security: Optional['outputs.ElasticsearchSecurityRoleIndexFieldSecurity'] = None,
                 query: Optional[str] = None):
        """
        :param Sequence[str] names: A list of indices (or index name patterns) to which the permissions in this entry apply.
        :param Sequence[str] privileges: The index level privileges that the owners of the role have on the specified indices.
        :param 'ElasticsearchSecurityRoleIndexFieldSecurityArgs' field_security: The document fields that the owners of the role have read access to.
        :param str query: A search query that defines the documents the owners of the role have read access to.
        """
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "privileges", privileges)
        if field_security is not None:
            pulumi.set(__self__, "field_security", field_security)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def names(self) -> Sequence[str]:
        """
        A list of indices (or index name patterns) to which the permissions in this entry apply.
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def privileges(self) -> Sequence[str]:
        """
        The index level privileges that the owners of the role have on the specified indices.
        """
        return pulumi.get(self, "privileges")

    @property
    @pulumi.getter(name="fieldSecurity")
    def field_security(self) -> Optional['outputs.ElasticsearchSecurityRoleIndexFieldSecurity']:
        """
        The document fields that the owners of the role have read access to.
        """
        return pulumi.get(self, "field_security")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        A search query that defines the documents the owners of the role have read access to.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class ElasticsearchSecurityRoleIndexFieldSecurity(dict):
    def __init__(__self__, *,
                 excepts: Optional[Sequence[str]] = None,
                 grants: Optional[Sequence[str]] = None):
        if excepts is not None:
            pulumi.set(__self__, "excepts", excepts)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)

    @property
    @pulumi.getter
    def excepts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "excepts")

    @property
    @pulumi.getter
    def grants(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "grants")


@pulumi.output_type
class ElasticsearchSecurityUserElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSecurityUserElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSecurityUserElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSecurityUserElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchSnapshotLifecycleElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotLifecycleElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotLifecycleElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotLifecycleElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePath":
            suggest = "base_path"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "locationMode":
            suggest = "location_mode"
        elif key == "maxRestoreBytesPerSec":
            suggest = "max_restore_bytes_per_sec"
        elif key == "maxSnapshotBytesPerSec":
            suggest = "max_snapshot_bytes_per_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container: str,
                 base_path: Optional[str] = None,
                 chunk_size: Optional[str] = None,
                 client: Optional[str] = None,
                 compress: Optional[bool] = None,
                 location_mode: Optional[str] = None,
                 max_restore_bytes_per_sec: Optional[str] = None,
                 max_snapshot_bytes_per_sec: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str container: Container name. You must create the Azure container before creating the repository.
        :param str base_path: Specifies the path within the container to the repository data.
        :param str chunk_size: Maximum size of files in snapshots.
        :param str client: Azure named client to use.
        :param bool compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param str location_mode: Location mode. `primary_only` or `secondary_only`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
        :param str max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param str max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param bool readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "container", container)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if location_mode is not None:
            pulumi.set(__self__, "location_mode", location_mode)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        Container name. You must create the Azure container before creating the repository.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[str]:
        """
        Specifies the path within the container to the repository data.
        """
        return pulumi.get(self, "base_path")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def client(self) -> Optional[str]:
        """
        Azure named client to use.
        """
        return pulumi.get(self, "client")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="locationMode")
    def location_mode(self) -> Optional[str]:
        """
        Location mode. `primary_only` or `secondary_only`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
        """
        return pulumi.get(self, "location_mode")

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryElasticsearchConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caFile":
            suggest = "ca_file"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryElasticsearchConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryElasticsearchConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryElasticsearchConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_file: Optional[str] = None,
                 endpoints: Optional[Sequence[str]] = None,
                 insecure: Optional[bool] = None,
                 password: Optional[str] = None,
                 username: Optional[str] = None):
        """
        :param str ca_file: Path to a custom Certificate Authority certificate
        :param bool insecure: Disable TLS certificate validation
        :param str password: A password to use for API authentication to Elasticsearch.
        :param str username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[str]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter
    def insecure(self) -> Optional[bool]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryFs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "maxNumberOfSnapshots":
            suggest = "max_number_of_snapshots"
        elif key == "maxRestoreBytesPerSec":
            suggest = "max_restore_bytes_per_sec"
        elif key == "maxSnapshotBytesPerSec":
            suggest = "max_snapshot_bytes_per_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryFs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryFs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryFs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: str,
                 chunk_size: Optional[str] = None,
                 compress: Optional[bool] = None,
                 max_number_of_snapshots: Optional[int] = None,
                 max_restore_bytes_per_sec: Optional[str] = None,
                 max_snapshot_bytes_per_sec: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str location: Location of the shared filesystem used to store and retrieve snapshots.
        :param str chunk_size: Maximum size of files in snapshots.
        :param bool compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param int max_number_of_snapshots: Maximum number of snapshots the repository can contain.
        :param str max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param str max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param bool readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "location", location)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if max_number_of_snapshots is not None:
            pulumi.set(__self__, "max_number_of_snapshots", max_number_of_snapshots)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def location(self) -> str:
        """
        Location of the shared filesystem used to store and retrieve snapshots.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="maxNumberOfSnapshots")
    def max_number_of_snapshots(self) -> Optional[int]:
        """
        Maximum number of snapshots the repository can contain.
        """
        return pulumi.get(self, "max_number_of_snapshots")

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryGcs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePath":
            suggest = "base_path"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "maxRestoreBytesPerSec":
            suggest = "max_restore_bytes_per_sec"
        elif key == "maxSnapshotBytesPerSec":
            suggest = "max_snapshot_bytes_per_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryGcs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryGcs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryGcs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 base_path: Optional[str] = None,
                 chunk_size: Optional[str] = None,
                 client: Optional[str] = None,
                 compress: Optional[bool] = None,
                 max_restore_bytes_per_sec: Optional[str] = None,
                 max_snapshot_bytes_per_sec: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str bucket: The name of the bucket to be used for snapshots.
        :param str base_path: Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.
        :param str chunk_size: Maximum size of files in snapshots.
        :param str client: The name of the client to use to connect to Google Cloud Storage.
        :param bool compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param str max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param str max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param bool readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "bucket", bucket)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        The name of the bucket to be used for snapshots.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[str]:
        """
        Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.
        """
        return pulumi.get(self, "base_path")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def client(self) -> Optional[str]:
        """
        The name of the client to use to connect to Google Cloud Storage.
        """
        return pulumi.get(self, "client")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryHdfs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "loadDefaults":
            suggest = "load_defaults"
        elif key == "maxRestoreBytesPerSec":
            suggest = "max_restore_bytes_per_sec"
        elif key == "maxSnapshotBytesPerSec":
            suggest = "max_snapshot_bytes_per_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryHdfs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryHdfs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryHdfs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 uri: str,
                 chunk_size: Optional[str] = None,
                 compress: Optional[bool] = None,
                 load_defaults: Optional[bool] = None,
                 max_restore_bytes_per_sec: Optional[str] = None,
                 max_snapshot_bytes_per_sec: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str path: The file path within the filesystem where data is stored/loaded.
        :param str uri: The uri address for hdfs. ex: "hdfs://\n\n:\n\n/".
        :param str chunk_size: Maximum size of files in snapshots.
        :param bool compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param bool load_defaults: Whether to load the default Hadoop configuration or not.
        :param str max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param str max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param bool readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "uri", uri)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if load_defaults is not None:
            pulumi.set(__self__, "load_defaults", load_defaults)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The file path within the filesystem where data is stored/loaded.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The uri address for hdfs. ex: "hdfs://\n\n:\n\n/".
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="loadDefaults")
    def load_defaults(self) -> Optional[bool]:
        """
        Whether to load the default Hadoop configuration or not.
        """
        return pulumi.get(self, "load_defaults")

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basePath":
            suggest = "base_path"
        elif key == "bufferSize":
            suggest = "buffer_size"
        elif key == "cannedAcl":
            suggest = "canned_acl"
        elif key == "chunkSize":
            suggest = "chunk_size"
        elif key == "maxRestoreBytesPerSec":
            suggest = "max_restore_bytes_per_sec"
        elif key == "maxSnapshotBytesPerSec":
            suggest = "max_snapshot_bytes_per_sec"
        elif key == "serverSideEncryption":
            suggest = "server_side_encryption"
        elif key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 base_path: Optional[str] = None,
                 buffer_size: Optional[str] = None,
                 canned_acl: Optional[str] = None,
                 chunk_size: Optional[str] = None,
                 client: Optional[str] = None,
                 compress: Optional[bool] = None,
                 max_restore_bytes_per_sec: Optional[str] = None,
                 max_snapshot_bytes_per_sec: Optional[str] = None,
                 readonly: Optional[bool] = None,
                 server_side_encryption: Optional[bool] = None,
                 storage_class: Optional[str] = None):
        """
        :param str bucket: Name of the S3 bucket to use for snapshots.
        :param str base_path: Specifies the path to the repository data within its bucket.
        :param str buffer_size: Minimum threshold below which the chunk is uploaded using a single request.
        :param str canned_acl: The S3 repository supports all S3 canned ACLs.
        :param str chunk_size: Maximum size of files in snapshots.
        :param str client: The name of the S3 client to use to connect to S3.
        :param bool compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param str max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param str max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param bool readonly: If true, the repository is read-only.
        :param bool server_side_encryption: When true, files are encrypted server-side using AES-256 algorithm.
        :param str storage_class: Sets the S3 storage class for objects stored in the snapshot repository.
        """
        pulumi.set(__self__, "bucket", bucket)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if buffer_size is not None:
            pulumi.set(__self__, "buffer_size", buffer_size)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of the S3 bucket to use for snapshots.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[str]:
        """
        Specifies the path to the repository data within its bucket.
        """
        return pulumi.get(self, "base_path")

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> Optional[str]:
        """
        Minimum threshold below which the chunk is uploaded using a single request.
        """
        return pulumi.get(self, "buffer_size")

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[str]:
        """
        The S3 repository supports all S3 canned ACLs.
        """
        return pulumi.get(self, "canned_acl")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def client(self) -> Optional[str]:
        """
        The name of the S3 client to use to connect to S3.
        """
        return pulumi.get(self, "client")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[bool]:
        """
        When true, files are encrypted server-side using AES-256 algorithm.
        """
        return pulumi.get(self, "server_side_encryption")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[str]:
        """
        Sets the S3 storage class for objects stored in the snapshot repository.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class ElasticsearchSnapshotRepositoryUrl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "httpMaxRetries":
            suggest = "http_max_retries"
        elif key == "httpSocketTimeout":
            suggest = "http_socket_timeout"
        elif key == "maxNumberOfSnapshots":
            suggest = "max_number_of_snapshots"
        elif key == "maxRestoreBytesPerSec":
            suggest = "max_restore_bytes_per_sec"
        elif key == "maxSnapshotBytesPerSec":
            suggest = "max_snapshot_bytes_per_sec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElasticsearchSnapshotRepositoryUrl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElasticsearchSnapshotRepositoryUrl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElasticsearchSnapshotRepositoryUrl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 chunk_size: Optional[str] = None,
                 compress: Optional[bool] = None,
                 http_max_retries: Optional[int] = None,
                 http_socket_timeout: Optional[str] = None,
                 max_number_of_snapshots: Optional[int] = None,
                 max_restore_bytes_per_sec: Optional[str] = None,
                 max_snapshot_bytes_per_sec: Optional[str] = None,
                 readonly: Optional[bool] = None):
        """
        :param str url: URL location of the root of the shared filesystem repository.
        :param str chunk_size: Maximum size of files in snapshots.
        :param bool compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param int http_max_retries: Maximum number of retries for http and https URLs.
        :param str http_socket_timeout: Maximum wait time for data transfers over a connection.
        :param int max_number_of_snapshots: Maximum number of snapshots the repository can contain.
        :param str max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param str max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param bool readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "url", url)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if http_max_retries is not None:
            pulumi.set(__self__, "http_max_retries", http_max_retries)
        if http_socket_timeout is not None:
            pulumi.set(__self__, "http_socket_timeout", http_socket_timeout)
        if max_number_of_snapshots is not None:
            pulumi.set(__self__, "max_number_of_snapshots", max_number_of_snapshots)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL location of the root of the shared filesystem repository.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[str]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @property
    @pulumi.getter
    def compress(self) -> Optional[bool]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @property
    @pulumi.getter(name="httpMaxRetries")
    def http_max_retries(self) -> Optional[int]:
        """
        Maximum number of retries for http and https URLs.
        """
        return pulumi.get(self, "http_max_retries")

    @property
    @pulumi.getter(name="httpSocketTimeout")
    def http_socket_timeout(self) -> Optional[str]:
        """
        Maximum wait time for data transfers over a connection.
        """
        return pulumi.get(self, "http_socket_timeout")

    @property
    @pulumi.getter(name="maxNumberOfSnapshots")
    def max_number_of_snapshots(self) -> Optional[int]:
        """
        Maximum number of snapshots the repository can contain.
        """
        return pulumi.get(self, "max_number_of_snapshots")

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[str]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @property
    @pulumi.getter
    def readonly(self) -> Optional[bool]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")


