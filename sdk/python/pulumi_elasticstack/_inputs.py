# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'ElasticsearchClusterSettingsElasticsearchConnectionArgs',
    'ElasticsearchClusterSettingsPersistentArgs',
    'ElasticsearchClusterSettingsPersistentSettingArgs',
    'ElasticsearchClusterSettingsTransientArgs',
    'ElasticsearchClusterSettingsTransientSettingArgs',
    'ElasticsearchComponentTemplateElasticsearchConnectionArgs',
    'ElasticsearchComponentTemplateTemplateArgs',
    'ElasticsearchComponentTemplateTemplateAliasArgs',
    'ElasticsearchDataStreamElasticsearchConnectionArgs',
    'ElasticsearchDataStreamIndexArgs',
    'ElasticsearchIndexAliasArgs',
    'ElasticsearchIndexElasticsearchConnectionArgs',
    'ElasticsearchIndexLifecycleColdArgs',
    'ElasticsearchIndexLifecycleColdAllocateArgs',
    'ElasticsearchIndexLifecycleColdFreezeArgs',
    'ElasticsearchIndexLifecycleColdMigrateArgs',
    'ElasticsearchIndexLifecycleColdReadonlyArgs',
    'ElasticsearchIndexLifecycleColdSearchableSnapshotArgs',
    'ElasticsearchIndexLifecycleColdSetPriorityArgs',
    'ElasticsearchIndexLifecycleColdUnfollowArgs',
    'ElasticsearchIndexLifecycleDeleteArgs',
    'ElasticsearchIndexLifecycleDeleteDeleteArgs',
    'ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs',
    'ElasticsearchIndexLifecycleElasticsearchConnectionArgs',
    'ElasticsearchIndexLifecycleFrozenArgs',
    'ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs',
    'ElasticsearchIndexLifecycleHotArgs',
    'ElasticsearchIndexLifecycleHotForcemergeArgs',
    'ElasticsearchIndexLifecycleHotReadonlyArgs',
    'ElasticsearchIndexLifecycleHotRolloverArgs',
    'ElasticsearchIndexLifecycleHotSearchableSnapshotArgs',
    'ElasticsearchIndexLifecycleHotSetPriorityArgs',
    'ElasticsearchIndexLifecycleHotShrinkArgs',
    'ElasticsearchIndexLifecycleHotUnfollowArgs',
    'ElasticsearchIndexLifecycleWarmArgs',
    'ElasticsearchIndexLifecycleWarmAllocateArgs',
    'ElasticsearchIndexLifecycleWarmForcemergeArgs',
    'ElasticsearchIndexLifecycleWarmMigrateArgs',
    'ElasticsearchIndexLifecycleWarmReadonlyArgs',
    'ElasticsearchIndexLifecycleWarmSetPriorityArgs',
    'ElasticsearchIndexLifecycleWarmShrinkArgs',
    'ElasticsearchIndexLifecycleWarmUnfollowArgs',
    'ElasticsearchIndexSettingsArgs',
    'ElasticsearchIndexSettingsSettingArgs',
    'ElasticsearchIndexTemplateDataStreamArgs',
    'ElasticsearchIndexTemplateElasticsearchConnectionArgs',
    'ElasticsearchIndexTemplateTemplateArgs',
    'ElasticsearchIndexTemplateTemplateAliasArgs',
    'ElasticsearchIngestPipelineElasticsearchConnectionArgs',
    'ElasticsearchSecurityRoleApplicationArgs',
    'ElasticsearchSecurityRoleElasticsearchConnectionArgs',
    'ElasticsearchSecurityRoleIndexArgs',
    'ElasticsearchSecurityRoleIndexFieldSecurityArgs',
    'ElasticsearchSecurityUserElasticsearchConnectionArgs',
    'ElasticsearchSnapshotLifecycleElasticsearchConnectionArgs',
    'ElasticsearchSnapshotRepositoryAzureArgs',
    'ElasticsearchSnapshotRepositoryElasticsearchConnectionArgs',
    'ElasticsearchSnapshotRepositoryFsArgs',
    'ElasticsearchSnapshotRepositoryGcsArgs',
    'ElasticsearchSnapshotRepositoryHdfsArgs',
    'ElasticsearchSnapshotRepositoryS3Args',
    'ElasticsearchSnapshotRepositoryUrlArgs',
    'ProviderElasticsearchArgs',
]

@pulumi.input_type
class ElasticsearchClusterSettingsElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchClusterSettingsPersistentArgs:
    def __init__(__self__, *,
                 settings: pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsPersistentSettingArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsPersistentSettingArgs']]] settings: Defines the setting in the cluster.
        """
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsPersistentSettingArgs']]]:
        """
        Defines the setting in the cluster.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsPersistentSettingArgs']]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ElasticsearchClusterSettingsPersistentSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value_lists", value)


@pulumi.input_type
class ElasticsearchClusterSettingsTransientArgs:
    def __init__(__self__, *,
                 settings: pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsTransientSettingArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsTransientSettingArgs']]] settings: Defines the setting in the cluster.
        """
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsTransientSettingArgs']]]:
        """
        Defines the setting in the cluster.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: pulumi.Input[Sequence[pulumi.Input['ElasticsearchClusterSettingsTransientSettingArgs']]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ElasticsearchClusterSettingsTransientSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: Optional[pulumi.Input[str]] = None,
                 value_lists: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_lists is not None:
            pulumi.set(__self__, "value_lists", value_lists)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueLists")
    def value_lists(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "value_lists")

    @value_lists.setter
    def value_lists(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "value_lists", value)


@pulumi.input_type
class ElasticsearchComponentTemplateElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchComponentTemplateTemplateArgs:
    def __init__(__self__, *,
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input['ElasticsearchComponentTemplateTemplateAliasArgs']]]] = None,
                 mappings: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElasticsearchComponentTemplateTemplateAliasArgs']]] aliases: Alias to add.
        :param pulumi.Input[str] mappings: Mapping for fields in the index.
        :param pulumi.Input[str] settings: Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElasticsearchComponentTemplateTemplateAliasArgs']]]]:
        """
        Alias to add.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElasticsearchComponentTemplateTemplateAliasArgs']]]]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[str]]:
        """
        Mapping for fields in the index.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mappings", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ElasticsearchComponentTemplateTemplateAliasArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 filter: Optional[pulumi.Input[str]] = None,
                 index_routing: Optional[pulumi.Input[str]] = None,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 is_write_index: Optional[pulumi.Input[bool]] = None,
                 routing: Optional[pulumi.Input[str]] = None,
                 search_routing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the component template to create.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if index_routing is not None:
            pulumi.set(__self__, "index_routing", index_routing)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_write_index is not None:
            pulumi.set(__self__, "is_write_index", is_write_index)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)
        if search_routing is not None:
            pulumi.set(__self__, "search_routing", search_routing)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the component template to create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="indexRouting")
    def index_routing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_routing")

    @index_routing.setter
    def index_routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_routing", value)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter(name="isWriteIndex")
    def is_write_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_write_index")

    @is_write_index.setter
    def is_write_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_write_index", value)

    @property
    @pulumi.getter
    def routing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "routing")

    @routing.setter
    def routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing", value)

    @property
    @pulumi.getter(name="searchRouting")
    def search_routing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_routing")

    @search_routing.setter
    def search_routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_routing", value)


@pulumi.input_type
class ElasticsearchDataStreamElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchDataStreamIndexArgs:
    def __init__(__self__, *,
                 index_name: Optional[pulumi.Input[str]] = None,
                 index_uuid: Optional[pulumi.Input[str]] = None):
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)
        if index_uuid is not None:
            pulumi.set(__self__, "index_uuid", index_uuid)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)

    @property
    @pulumi.getter(name="indexUuid")
    def index_uuid(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_uuid")

    @index_uuid.setter
    def index_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_uuid", value)


@pulumi.input_type
class ElasticsearchIndexAliasArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 filter: Optional[pulumi.Input[str]] = None,
                 index_routing: Optional[pulumi.Input[str]] = None,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 is_write_index: Optional[pulumi.Input[bool]] = None,
                 routing: Optional[pulumi.Input[str]] = None,
                 search_routing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Index alias name.
        :param pulumi.Input[str] filter: Query used to limit documents the alias can access.
        :param pulumi.Input[str] index_routing: Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
        :param pulumi.Input[bool] is_hidden: If true, the alias is hidden.
        :param pulumi.Input[bool] is_write_index: If true, the index is the write index for the alias.
        :param pulumi.Input[str] routing: Value used to route indexing and search operations to a specific shard.
        :param pulumi.Input[str] search_routing: Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if index_routing is not None:
            pulumi.set(__self__, "index_routing", index_routing)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_write_index is not None:
            pulumi.set(__self__, "is_write_index", is_write_index)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)
        if search_routing is not None:
            pulumi.set(__self__, "search_routing", search_routing)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Index alias name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        """
        Query used to limit documents the alias can access.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="indexRouting")
    def index_routing(self) -> Optional[pulumi.Input[str]]:
        """
        Value used to route indexing operations to a specific shard. If specified, this overwrites the `routing` value for indexing operations.
        """
        return pulumi.get(self, "index_routing")

    @index_routing.setter
    def index_routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_routing", value)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the alias is hidden.
        """
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter(name="isWriteIndex")
    def is_write_index(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the index is the write index for the alias.
        """
        return pulumi.get(self, "is_write_index")

    @is_write_index.setter
    def is_write_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_write_index", value)

    @property
    @pulumi.getter
    def routing(self) -> Optional[pulumi.Input[str]]:
        """
        Value used to route indexing and search operations to a specific shard.
        """
        return pulumi.get(self, "routing")

    @routing.setter
    def routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing", value)

    @property
    @pulumi.getter(name="searchRouting")
    def search_routing(self) -> Optional[pulumi.Input[str]]:
        """
        Value used to route search operations to a specific shard. If specified, this overwrites the routing value for search operations.
        """
        return pulumi.get(self, "search_routing")

    @search_routing.setter
    def search_routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_routing", value)


@pulumi.input_type
class ElasticsearchIndexElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdArgs:
    def __init__(__self__, *,
                 allocate: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdAllocateArgs']] = None,
                 freeze: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdFreezeArgs']] = None,
                 migrate: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdMigrateArgs']] = None,
                 min_age: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdReadonlyArgs']] = None,
                 searchable_snapshot: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdSearchableSnapshotArgs']] = None,
                 set_priority: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdSetPriorityArgs']] = None,
                 unfollow: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdUnfollowArgs']] = None):
        """
        :param pulumi.Input['ElasticsearchIndexLifecycleColdAllocateArgs'] allocate: Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        :param pulumi.Input['ElasticsearchIndexLifecycleColdFreezeArgs'] freeze: Freeze the index to minimize its memory footprint.
        :param pulumi.Input['ElasticsearchIndexLifecycleColdMigrateArgs'] migrate: Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        :param pulumi.Input[str] min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param pulumi.Input['ElasticsearchIndexLifecycleColdReadonlyArgs'] readonly: Makes the index read-only.
        :param pulumi.Input['ElasticsearchIndexLifecycleColdSearchableSnapshotArgs'] searchable_snapshot: Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        :param pulumi.Input['ElasticsearchIndexLifecycleColdSetPriorityArgs'] set_priority: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param pulumi.Input['ElasticsearchIndexLifecycleColdUnfollowArgs'] unfollow: Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        if allocate is not None:
            pulumi.set(__self__, "allocate", allocate)
        if freeze is not None:
            pulumi.set(__self__, "freeze", freeze)
        if migrate is not None:
            pulumi.set(__self__, "migrate", migrate)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if searchable_snapshot is not None:
            pulumi.set(__self__, "searchable_snapshot", searchable_snapshot)
        if set_priority is not None:
            pulumi.set(__self__, "set_priority", set_priority)
        if unfollow is not None:
            pulumi.set(__self__, "unfollow", unfollow)

    @property
    @pulumi.getter
    def allocate(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdAllocateArgs']]:
        """
        Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        """
        return pulumi.get(self, "allocate")

    @allocate.setter
    def allocate(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdAllocateArgs']]):
        pulumi.set(self, "allocate", value)

    @property
    @pulumi.getter
    def freeze(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdFreezeArgs']]:
        """
        Freeze the index to minimize its memory footprint.
        """
        return pulumi.get(self, "freeze")

    @freeze.setter
    def freeze(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdFreezeArgs']]):
        pulumi.set(self, "freeze", value)

    @property
    @pulumi.getter
    def migrate(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdMigrateArgs']]:
        """
        Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        """
        return pulumi.get(self, "migrate")

    @migrate.setter
    def migrate(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdMigrateArgs']]):
        pulumi.set(self, "migrate", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdReadonlyArgs']]:
        """
        Makes the index read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdReadonlyArgs']]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter(name="searchableSnapshot")
    def searchable_snapshot(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdSearchableSnapshotArgs']]:
        """
        Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        return pulumi.get(self, "searchable_snapshot")

    @searchable_snapshot.setter
    def searchable_snapshot(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdSearchableSnapshotArgs']]):
        pulumi.set(self, "searchable_snapshot", value)

    @property
    @pulumi.getter(name="setPriority")
    def set_priority(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdSetPriorityArgs']]:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "set_priority")

    @set_priority.setter
    def set_priority(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdSetPriorityArgs']]):
        pulumi.set(self, "set_priority", value)

    @property
    @pulumi.getter
    def unfollow(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleColdUnfollowArgs']]:
        """
        Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        return pulumi.get(self, "unfollow")

    @unfollow.setter
    def unfollow(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleColdUnfollowArgs']]):
        pulumi.set(self, "unfollow", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdAllocateArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input[str]] = None,
                 include: Optional[pulumi.Input[str]] = None,
                 number_of_replicas: Optional[pulumi.Input[int]] = None,
                 require: Optional[pulumi.Input[str]] = None):
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if require is not None:
            pulumi.set(__self__, "require", require)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter
    def require(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "require")

    @require.setter
    def require(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "require", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdFreezeArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdMigrateArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdReadonlyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdSearchableSnapshotArgs:
    def __init__(__self__, *,
                 snapshot_repository: pulumi.Input[str],
                 force_merge_index: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "snapshot_repository", snapshot_repository)
        if force_merge_index is not None:
            pulumi.set(__self__, "force_merge_index", force_merge_index)

    @property
    @pulumi.getter(name="snapshotRepository")
    def snapshot_repository(self) -> pulumi.Input[str]:
        return pulumi.get(self, "snapshot_repository")

    @snapshot_repository.setter
    def snapshot_repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "snapshot_repository", value)

    @property
    @pulumi.getter(name="forceMergeIndex")
    def force_merge_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "force_merge_index")

    @force_merge_index.setter
    def force_merge_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_merge_index", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdSetPriorityArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int]):
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleColdUnfollowArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleDeleteArgs:
    def __init__(__self__, *,
                 delete: Optional[pulumi.Input['ElasticsearchIndexLifecycleDeleteDeleteArgs']] = None,
                 min_age: Optional[pulumi.Input[str]] = None,
                 wait_for_snapshot: Optional[pulumi.Input['ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs']] = None):
        """
        :param pulumi.Input['ElasticsearchIndexLifecycleDeleteDeleteArgs'] delete: Permanently removes the index.
        :param pulumi.Input[str] min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param pulumi.Input['ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs'] wait_for_snapshot: Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.
        """
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if wait_for_snapshot is not None:
            pulumi.set(__self__, "wait_for_snapshot", wait_for_snapshot)

    @property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleDeleteDeleteArgs']]:
        """
        Permanently removes the index.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleDeleteDeleteArgs']]):
        pulumi.set(self, "delete", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)

    @property
    @pulumi.getter(name="waitForSnapshot")
    def wait_for_snapshot(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs']]:
        """
        Waits for the specified SLM policy to be executed before removing the index. This ensures that a snapshot of the deleted index is available.
        """
        return pulumi.get(self, "wait_for_snapshot")

    @wait_for_snapshot.setter
    def wait_for_snapshot(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs']]):
        pulumi.set(self, "wait_for_snapshot", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleDeleteDeleteArgs:
    def __init__(__self__, *,
                 delete_searchable_snapshot: Optional[pulumi.Input[bool]] = None):
        if delete_searchable_snapshot is not None:
            pulumi.set(__self__, "delete_searchable_snapshot", delete_searchable_snapshot)

    @property
    @pulumi.getter(name="deleteSearchableSnapshot")
    def delete_searchable_snapshot(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "delete_searchable_snapshot")

    @delete_searchable_snapshot.setter
    def delete_searchable_snapshot(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "delete_searchable_snapshot", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleDeleteWaitForSnapshotArgs:
    def __init__(__self__, *,
                 policy: pulumi.Input[str]):
        pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> pulumi.Input[str]:
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: pulumi.Input[str]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleFrozenArgs:
    def __init__(__self__, *,
                 min_age: Optional[pulumi.Input[str]] = None,
                 searchable_snapshot: Optional[pulumi.Input['ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs']] = None):
        """
        :param pulumi.Input[str] min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param pulumi.Input['ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs'] searchable_snapshot: Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if searchable_snapshot is not None:
            pulumi.set(__self__, "searchable_snapshot", searchable_snapshot)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)

    @property
    @pulumi.getter(name="searchableSnapshot")
    def searchable_snapshot(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs']]:
        """
        Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        return pulumi.get(self, "searchable_snapshot")

    @searchable_snapshot.setter
    def searchable_snapshot(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs']]):
        pulumi.set(self, "searchable_snapshot", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleFrozenSearchableSnapshotArgs:
    def __init__(__self__, *,
                 snapshot_repository: pulumi.Input[str],
                 force_merge_index: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "snapshot_repository", snapshot_repository)
        if force_merge_index is not None:
            pulumi.set(__self__, "force_merge_index", force_merge_index)

    @property
    @pulumi.getter(name="snapshotRepository")
    def snapshot_repository(self) -> pulumi.Input[str]:
        return pulumi.get(self, "snapshot_repository")

    @snapshot_repository.setter
    def snapshot_repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "snapshot_repository", value)

    @property
    @pulumi.getter(name="forceMergeIndex")
    def force_merge_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "force_merge_index")

    @force_merge_index.setter
    def force_merge_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_merge_index", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotArgs:
    def __init__(__self__, *,
                 forcemerge: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotForcemergeArgs']] = None,
                 min_age: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotReadonlyArgs']] = None,
                 rollover: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotRolloverArgs']] = None,
                 searchable_snapshot: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotSearchableSnapshotArgs']] = None,
                 set_priority: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotSetPriorityArgs']] = None,
                 shrink: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotShrinkArgs']] = None,
                 unfollow: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotUnfollowArgs']] = None):
        """
        :param pulumi.Input['ElasticsearchIndexLifecycleHotForcemergeArgs'] forcemerge: Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        :param pulumi.Input[str] min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param pulumi.Input['ElasticsearchIndexLifecycleHotReadonlyArgs'] readonly: Makes the index read-only.
        :param pulumi.Input['ElasticsearchIndexLifecycleHotRolloverArgs'] rollover: Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.
        :param pulumi.Input['ElasticsearchIndexLifecycleHotSearchableSnapshotArgs'] searchable_snapshot: Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        :param pulumi.Input['ElasticsearchIndexLifecycleHotSetPriorityArgs'] set_priority: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param pulumi.Input['ElasticsearchIndexLifecycleHotShrinkArgs'] shrink: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param pulumi.Input['ElasticsearchIndexLifecycleHotUnfollowArgs'] unfollow: Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        if forcemerge is not None:
            pulumi.set(__self__, "forcemerge", forcemerge)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if rollover is not None:
            pulumi.set(__self__, "rollover", rollover)
        if searchable_snapshot is not None:
            pulumi.set(__self__, "searchable_snapshot", searchable_snapshot)
        if set_priority is not None:
            pulumi.set(__self__, "set_priority", set_priority)
        if shrink is not None:
            pulumi.set(__self__, "shrink", shrink)
        if unfollow is not None:
            pulumi.set(__self__, "unfollow", unfollow)

    @property
    @pulumi.getter
    def forcemerge(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotForcemergeArgs']]:
        """
        Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        """
        return pulumi.get(self, "forcemerge")

    @forcemerge.setter
    def forcemerge(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotForcemergeArgs']]):
        pulumi.set(self, "forcemerge", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotReadonlyArgs']]:
        """
        Makes the index read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotReadonlyArgs']]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter
    def rollover(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotRolloverArgs']]:
        """
        Rolls over a target to a new index when the existing index meets one or more of the rollover conditions.
        """
        return pulumi.get(self, "rollover")

    @rollover.setter
    def rollover(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotRolloverArgs']]):
        pulumi.set(self, "rollover", value)

    @property
    @pulumi.getter(name="searchableSnapshot")
    def searchable_snapshot(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotSearchableSnapshotArgs']]:
        """
        Takes a snapshot of the managed index in the configured repository and mounts it as a searchable snapshot.
        """
        return pulumi.get(self, "searchable_snapshot")

    @searchable_snapshot.setter
    def searchable_snapshot(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotSearchableSnapshotArgs']]):
        pulumi.set(self, "searchable_snapshot", value)

    @property
    @pulumi.getter(name="setPriority")
    def set_priority(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotSetPriorityArgs']]:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "set_priority")

    @set_priority.setter
    def set_priority(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotSetPriorityArgs']]):
        pulumi.set(self, "set_priority", value)

    @property
    @pulumi.getter
    def shrink(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotShrinkArgs']]:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "shrink")

    @shrink.setter
    def shrink(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotShrinkArgs']]):
        pulumi.set(self, "shrink", value)

    @property
    @pulumi.getter
    def unfollow(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleHotUnfollowArgs']]:
        """
        Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        return pulumi.get(self, "unfollow")

    @unfollow.setter
    def unfollow(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleHotUnfollowArgs']]):
        pulumi.set(self, "unfollow", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotForcemergeArgs:
    def __init__(__self__, *,
                 max_num_segments: pulumi.Input[int],
                 index_codec: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "max_num_segments", max_num_segments)
        if index_codec is not None:
            pulumi.set(__self__, "index_codec", index_codec)

    @property
    @pulumi.getter(name="maxNumSegments")
    def max_num_segments(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_num_segments")

    @max_num_segments.setter
    def max_num_segments(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_num_segments", value)

    @property
    @pulumi.getter(name="indexCodec")
    def index_codec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_codec")

    @index_codec.setter
    def index_codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_codec", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotReadonlyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotRolloverArgs:
    def __init__(__self__, *,
                 max_age: Optional[pulumi.Input[str]] = None,
                 max_docs: Optional[pulumi.Input[int]] = None,
                 max_primary_shard_size: Optional[pulumi.Input[str]] = None,
                 max_size: Optional[pulumi.Input[str]] = None):
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_docs is not None:
            pulumi.set(__self__, "max_docs", max_docs)
        if max_primary_shard_size is not None:
            pulumi.set(__self__, "max_primary_shard_size", max_primary_shard_size)
        if max_size is not None:
            pulumi.set(__self__, "max_size", max_size)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)

    @property
    @pulumi.getter(name="maxDocs")
    def max_docs(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_docs")

    @max_docs.setter
    def max_docs(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_docs", value)

    @property
    @pulumi.getter(name="maxPrimaryShardSize")
    def max_primary_shard_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_primary_shard_size")

    @max_primary_shard_size.setter
    def max_primary_shard_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_primary_shard_size", value)

    @property
    @pulumi.getter(name="maxSize")
    def max_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_size")

    @max_size.setter
    def max_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_size", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotSearchableSnapshotArgs:
    def __init__(__self__, *,
                 snapshot_repository: pulumi.Input[str],
                 force_merge_index: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "snapshot_repository", snapshot_repository)
        if force_merge_index is not None:
            pulumi.set(__self__, "force_merge_index", force_merge_index)

    @property
    @pulumi.getter(name="snapshotRepository")
    def snapshot_repository(self) -> pulumi.Input[str]:
        return pulumi.get(self, "snapshot_repository")

    @snapshot_repository.setter
    def snapshot_repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "snapshot_repository", value)

    @property
    @pulumi.getter(name="forceMergeIndex")
    def force_merge_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "force_merge_index")

    @force_merge_index.setter
    def force_merge_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "force_merge_index", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotSetPriorityArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int]):
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotShrinkArgs:
    def __init__(__self__, *,
                 max_primary_shard_size: Optional[pulumi.Input[str]] = None,
                 number_of_shards: Optional[pulumi.Input[int]] = None):
        if max_primary_shard_size is not None:
            pulumi.set(__self__, "max_primary_shard_size", max_primary_shard_size)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="maxPrimaryShardSize")
    def max_primary_shard_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_primary_shard_size")

    @max_primary_shard_size.setter
    def max_primary_shard_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_primary_shard_size", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_shards", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleHotUnfollowArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmArgs:
    def __init__(__self__, *,
                 allocate: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmAllocateArgs']] = None,
                 forcemerge: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmForcemergeArgs']] = None,
                 migrate: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmMigrateArgs']] = None,
                 min_age: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmReadonlyArgs']] = None,
                 set_priority: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmSetPriorityArgs']] = None,
                 shrink: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmShrinkArgs']] = None,
                 unfollow: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmUnfollowArgs']] = None):
        """
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmAllocateArgs'] allocate: Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmForcemergeArgs'] forcemerge: Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmMigrateArgs'] migrate: Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        :param pulumi.Input[str] min_age: ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmReadonlyArgs'] readonly: Makes the index read-only.
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmSetPriorityArgs'] set_priority: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmShrinkArgs'] shrink: Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        :param pulumi.Input['ElasticsearchIndexLifecycleWarmUnfollowArgs'] unfollow: Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        if allocate is not None:
            pulumi.set(__self__, "allocate", allocate)
        if forcemerge is not None:
            pulumi.set(__self__, "forcemerge", forcemerge)
        if migrate is not None:
            pulumi.set(__self__, "migrate", migrate)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if set_priority is not None:
            pulumi.set(__self__, "set_priority", set_priority)
        if shrink is not None:
            pulumi.set(__self__, "shrink", shrink)
        if unfollow is not None:
            pulumi.set(__self__, "unfollow", unfollow)

    @property
    @pulumi.getter
    def allocate(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmAllocateArgs']]:
        """
        Updates the index settings to change which nodes are allowed to host the index shards and change the number of replicas.
        """
        return pulumi.get(self, "allocate")

    @allocate.setter
    def allocate(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmAllocateArgs']]):
        pulumi.set(self, "allocate", value)

    @property
    @pulumi.getter
    def forcemerge(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmForcemergeArgs']]:
        """
        Force merges the index into the specified maximum number of segments. This action makes the index read-only.
        """
        return pulumi.get(self, "forcemerge")

    @forcemerge.setter
    def forcemerge(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmForcemergeArgs']]):
        pulumi.set(self, "forcemerge", value)

    @property
    @pulumi.getter
    def migrate(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmMigrateArgs']]:
        """
        Moves the index to the data tier that corresponds to the current phase by updating the "index.routing.allocation.include.*tier*preference" index setting.
        """
        return pulumi.get(self, "migrate")

    @migrate.setter
    def migrate(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmMigrateArgs']]):
        pulumi.set(self, "migrate", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        ILM moves indices through the lifecycle according to their age. To control the timing of these transitions, you set a minimum age for each phase.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmReadonlyArgs']]:
        """
        Makes the index read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmReadonlyArgs']]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter(name="setPriority")
    def set_priority(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmSetPriorityArgs']]:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "set_priority")

    @set_priority.setter
    def set_priority(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmSetPriorityArgs']]):
        pulumi.set(self, "set_priority", value)

    @property
    @pulumi.getter
    def shrink(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmShrinkArgs']]:
        """
        Sets a source index to read-only and shrinks it into a new index with fewer primary shards.
        """
        return pulumi.get(self, "shrink")

    @shrink.setter
    def shrink(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmShrinkArgs']]):
        pulumi.set(self, "shrink", value)

    @property
    @pulumi.getter
    def unfollow(self) -> Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmUnfollowArgs']]:
        """
        Convert a follower index to a regular index. Performed automatically before a rollover, shrink, or searchable snapshot action.
        """
        return pulumi.get(self, "unfollow")

    @unfollow.setter
    def unfollow(self, value: Optional[pulumi.Input['ElasticsearchIndexLifecycleWarmUnfollowArgs']]):
        pulumi.set(self, "unfollow", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmAllocateArgs:
    def __init__(__self__, *,
                 exclude: Optional[pulumi.Input[str]] = None,
                 include: Optional[pulumi.Input[str]] = None,
                 number_of_replicas: Optional[pulumi.Input[int]] = None,
                 require: Optional[pulumi.Input[str]] = None):
        if exclude is not None:
            pulumi.set(__self__, "exclude", exclude)
        if include is not None:
            pulumi.set(__self__, "include", include)
        if number_of_replicas is not None:
            pulumi.set(__self__, "number_of_replicas", number_of_replicas)
        if require is not None:
            pulumi.set(__self__, "require", require)

    @property
    @pulumi.getter
    def exclude(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "exclude")

    @exclude.setter
    def exclude(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclude", value)

    @property
    @pulumi.getter
    def include(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "include")

    @include.setter
    def include(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "include", value)

    @property
    @pulumi.getter(name="numberOfReplicas")
    def number_of_replicas(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_replicas")

    @number_of_replicas.setter
    def number_of_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_replicas", value)

    @property
    @pulumi.getter
    def require(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "require")

    @require.setter
    def require(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "require", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmForcemergeArgs:
    def __init__(__self__, *,
                 max_num_segments: pulumi.Input[int],
                 index_codec: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "max_num_segments", max_num_segments)
        if index_codec is not None:
            pulumi.set(__self__, "index_codec", index_codec)

    @property
    @pulumi.getter(name="maxNumSegments")
    def max_num_segments(self) -> pulumi.Input[int]:
        return pulumi.get(self, "max_num_segments")

    @max_num_segments.setter
    def max_num_segments(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_num_segments", value)

    @property
    @pulumi.getter(name="indexCodec")
    def index_codec(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_codec")

    @index_codec.setter
    def index_codec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_codec", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmMigrateArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmReadonlyArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmSetPriorityArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[int]):
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[int]:
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[int]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmShrinkArgs:
    def __init__(__self__, *,
                 max_primary_shard_size: Optional[pulumi.Input[str]] = None,
                 number_of_shards: Optional[pulumi.Input[int]] = None):
        if max_primary_shard_size is not None:
            pulumi.set(__self__, "max_primary_shard_size", max_primary_shard_size)
        if number_of_shards is not None:
            pulumi.set(__self__, "number_of_shards", number_of_shards)

    @property
    @pulumi.getter(name="maxPrimaryShardSize")
    def max_primary_shard_size(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_primary_shard_size")

    @max_primary_shard_size.setter
    def max_primary_shard_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_primary_shard_size", value)

    @property
    @pulumi.getter(name="numberOfShards")
    def number_of_shards(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number_of_shards")

    @number_of_shards.setter
    def number_of_shards(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_of_shards", value)


@pulumi.input_type
class ElasticsearchIndexLifecycleWarmUnfollowArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ElasticsearchIndexSettingsArgs:
    def __init__(__self__, *,
                 settings: pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexSettingsSettingArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexSettingsSettingArgs']]] settings: Defines the setting for the index.
        """
        pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def settings(self) -> pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexSettingsSettingArgs']]]:
        """
        Defines the setting for the index.
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexSettingsSettingArgs']]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ElasticsearchIndexSettingsSettingArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the index you wish to create.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the index you wish to create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ElasticsearchIndexTemplateDataStreamArgs:
    def __init__(__self__, *,
                 hidden: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] hidden: If true, the data stream is hidden.
        """
        if hidden is not None:
            pulumi.set(__self__, "hidden", hidden)

    @property
    @pulumi.getter
    def hidden(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the data stream is hidden.
        """
        return pulumi.get(self, "hidden")

    @hidden.setter
    def hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hidden", value)


@pulumi.input_type
class ElasticsearchIndexTemplateElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchIndexTemplateTemplateArgs:
    def __init__(__self__, *,
                 aliases: Optional[pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexTemplateTemplateAliasArgs']]]] = None,
                 mappings: Optional[pulumi.Input[str]] = None,
                 settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexTemplateTemplateAliasArgs']]] aliases: Alias to add.
        :param pulumi.Input[str] mappings: Mapping for fields in the index.
        :param pulumi.Input[str] settings: Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        if aliases is not None:
            pulumi.set(__self__, "aliases", aliases)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)
        if settings is not None:
            pulumi.set(__self__, "settings", settings)

    @property
    @pulumi.getter
    def aliases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexTemplateTemplateAliasArgs']]]]:
        """
        Alias to add.
        """
        return pulumi.get(self, "aliases")

    @aliases.setter
    def aliases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElasticsearchIndexTemplateTemplateAliasArgs']]]]):
        pulumi.set(self, "aliases", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[str]]:
        """
        Mapping for fields in the index.
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mappings", value)

    @property
    @pulumi.getter
    def settings(self) -> Optional[pulumi.Input[str]]:
        """
        Configuration options for the index. See, https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html#index-modules-settings
        """
        return pulumi.get(self, "settings")

    @settings.setter
    def settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "settings", value)


@pulumi.input_type
class ElasticsearchIndexTemplateTemplateAliasArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 filter: Optional[pulumi.Input[str]] = None,
                 index_routing: Optional[pulumi.Input[str]] = None,
                 is_hidden: Optional[pulumi.Input[bool]] = None,
                 is_write_index: Optional[pulumi.Input[bool]] = None,
                 routing: Optional[pulumi.Input[str]] = None,
                 search_routing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the index template to create.
        """
        pulumi.set(__self__, "name", name)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if index_routing is not None:
            pulumi.set(__self__, "index_routing", index_routing)
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if is_write_index is not None:
            pulumi.set(__self__, "is_write_index", is_write_index)
        if routing is not None:
            pulumi.set(__self__, "routing", routing)
        if search_routing is not None:
            pulumi.set(__self__, "search_routing", search_routing)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the index template to create.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter(name="indexRouting")
    def index_routing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "index_routing")

    @index_routing.setter
    def index_routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_routing", value)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_hidden")

    @is_hidden.setter
    def is_hidden(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_hidden", value)

    @property
    @pulumi.getter(name="isWriteIndex")
    def is_write_index(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_write_index")

    @is_write_index.setter
    def is_write_index(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_write_index", value)

    @property
    @pulumi.getter
    def routing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "routing")

    @routing.setter
    def routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing", value)

    @property
    @pulumi.getter(name="searchRouting")
    def search_routing(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "search_routing")

    @search_routing.setter
    def search_routing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_routing", value)


@pulumi.input_type
class ElasticsearchIngestPipelineElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchSecurityRoleApplicationArgs:
    def __init__(__self__, *,
                 application: pulumi.Input[str],
                 privileges: pulumi.Input[Sequence[pulumi.Input[str]]],
                 resources: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] application: The name of the application to which this entry applies.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] privileges: A list of strings, where each element is the name of an application privilege or action.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] resources: A list resources to which the privileges are applied.
        """
        pulumi.set(__self__, "application", application)
        pulumi.set(__self__, "privileges", privileges)
        pulumi.set(__self__, "resources", resources)

    @property
    @pulumi.getter
    def application(self) -> pulumi.Input[str]:
        """
        The name of the application to which this entry applies.
        """
        return pulumi.get(self, "application")

    @application.setter
    def application(self, value: pulumi.Input[str]):
        pulumi.set(self, "application", value)

    @property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of strings, where each element is the name of an application privilege or action.
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "privileges", value)

    @property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list resources to which the privileges are applied.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "resources", value)


@pulumi.input_type
class ElasticsearchSecurityRoleElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchSecurityRoleIndexArgs:
    def __init__(__self__, *,
                 names: pulumi.Input[Sequence[pulumi.Input[str]]],
                 privileges: pulumi.Input[Sequence[pulumi.Input[str]]],
                 field_security: Optional[pulumi.Input['ElasticsearchSecurityRoleIndexFieldSecurityArgs']] = None,
                 query: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] names: A list of indices (or index name patterns) to which the permissions in this entry apply.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] privileges: The index level privileges that the owners of the role have on the specified indices.
        :param pulumi.Input['ElasticsearchSecurityRoleIndexFieldSecurityArgs'] field_security: The document fields that the owners of the role have read access to.
        :param pulumi.Input[str] query: A search query that defines the documents the owners of the role have read access to.
        """
        pulumi.set(__self__, "names", names)
        pulumi.set(__self__, "privileges", privileges)
        if field_security is not None:
            pulumi.set(__self__, "field_security", field_security)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of indices (or index name patterns) to which the permissions in this entry apply.
        """
        return pulumi.get(self, "names")

    @names.setter
    def names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "names", value)

    @property
    @pulumi.getter
    def privileges(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The index level privileges that the owners of the role have on the specified indices.
        """
        return pulumi.get(self, "privileges")

    @privileges.setter
    def privileges(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "privileges", value)

    @property
    @pulumi.getter(name="fieldSecurity")
    def field_security(self) -> Optional[pulumi.Input['ElasticsearchSecurityRoleIndexFieldSecurityArgs']]:
        """
        The document fields that the owners of the role have read access to.
        """
        return pulumi.get(self, "field_security")

    @field_security.setter
    def field_security(self, value: Optional[pulumi.Input['ElasticsearchSecurityRoleIndexFieldSecurityArgs']]):
        pulumi.set(self, "field_security", value)

    @property
    @pulumi.getter
    def query(self) -> Optional[pulumi.Input[str]]:
        """
        A search query that defines the documents the owners of the role have read access to.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query", value)


@pulumi.input_type
class ElasticsearchSecurityRoleIndexFieldSecurityArgs:
    def __init__(__self__, *,
                 excepts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 grants: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        if excepts is not None:
            pulumi.set(__self__, "excepts", excepts)
        if grants is not None:
            pulumi.set(__self__, "grants", grants)

    @property
    @pulumi.getter
    def excepts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "excepts")

    @excepts.setter
    def excepts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "excepts", value)

    @property
    @pulumi.getter
    def grants(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "grants")

    @grants.setter
    def grants(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "grants", value)


@pulumi.input_type
class ElasticsearchSecurityUserElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchSnapshotLifecycleElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryAzureArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[str],
                 base_path: Optional[pulumi.Input[str]] = None,
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 client: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 location_mode: Optional[pulumi.Input[str]] = None,
                 max_restore_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 max_snapshot_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] container: Container name. You must create the Azure container before creating the repository.
        :param pulumi.Input[str] base_path: Specifies the path within the container to the repository data.
        :param pulumi.Input[str] chunk_size: Maximum size of files in snapshots.
        :param pulumi.Input[str] client: Azure named client to use.
        :param pulumi.Input[bool] compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param pulumi.Input[str] location_mode: Location mode. `primary_only` or `secondary_only`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
        :param pulumi.Input[str] max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param pulumi.Input[str] max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param pulumi.Input[bool] readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "container", container)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if location_mode is not None:
            pulumi.set(__self__, "location_mode", location_mode)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def container(self) -> pulumi.Input[str]:
        """
        Container name. You must create the Azure container before creating the repository.
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[str]):
        pulumi.set(self, "container", value)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path within the container to the repository data.
        """
        return pulumi.get(self, "base_path")

    @base_path.setter
    def base_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_path", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[str]]:
        """
        Azure named client to use.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="locationMode")
    def location_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Location mode. `primary_only` or `secondary_only`. See: https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy
        """
        return pulumi.get(self, "location_mode")

    @location_mode.setter
    def location_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_mode", value)

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @max_restore_bytes_per_sec.setter
    def max_restore_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_restore_bytes_per_sec", value)

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @max_snapshot_bytes_per_sec.setter
    def max_snapshot_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_snapshot_bytes_per_sec", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryElasticsearchConnectionArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ca_file: Path to a custom Certificate Authority certificate
        :param pulumi.Input[bool] insecure: Disable TLS certificate validation
        :param pulumi.Input[str] password: A password to use for API authentication to Elasticsearch.
        :param pulumi.Input[str] username: A username to use for API authentication to Elasticsearch.
        """
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a custom Certificate Authority certificate
        """
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable TLS certificate validation
        """
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        A password to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        """
        A username to use for API authentication to Elasticsearch.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryFsArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str],
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 max_number_of_snapshots: Optional[pulumi.Input[int]] = None,
                 max_restore_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 max_snapshot_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] location: Location of the shared filesystem used to store and retrieve snapshots.
        :param pulumi.Input[str] chunk_size: Maximum size of files in snapshots.
        :param pulumi.Input[bool] compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param pulumi.Input[int] max_number_of_snapshots: Maximum number of snapshots the repository can contain.
        :param pulumi.Input[str] max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param pulumi.Input[str] max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param pulumi.Input[bool] readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "location", location)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if max_number_of_snapshots is not None:
            pulumi.set(__self__, "max_number_of_snapshots", max_number_of_snapshots)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        Location of the shared filesystem used to store and retrieve snapshots.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="maxNumberOfSnapshots")
    def max_number_of_snapshots(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of snapshots the repository can contain.
        """
        return pulumi.get(self, "max_number_of_snapshots")

    @max_number_of_snapshots.setter
    def max_number_of_snapshots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_snapshots", value)

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @max_restore_bytes_per_sec.setter
    def max_restore_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_restore_bytes_per_sec", value)

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @max_snapshot_bytes_per_sec.setter
    def max_snapshot_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_snapshot_bytes_per_sec", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryGcsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 base_path: Optional[pulumi.Input[str]] = None,
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 client: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 max_restore_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 max_snapshot_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] bucket: The name of the bucket to be used for snapshots.
        :param pulumi.Input[str] base_path: Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.
        :param pulumi.Input[str] chunk_size: Maximum size of files in snapshots.
        :param pulumi.Input[str] client: The name of the client to use to connect to Google Cloud Storage.
        :param pulumi.Input[bool] compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param pulumi.Input[str] max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param pulumi.Input[str] max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param pulumi.Input[bool] readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "bucket", bucket)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The name of the bucket to be used for snapshots.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path within the bucket to the repository data. Defaults to the root of the bucket.
        """
        return pulumi.get(self, "base_path")

    @base_path.setter
    def base_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_path", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the client to use to connect to Google Cloud Storage.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @max_restore_bytes_per_sec.setter
    def max_restore_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_restore_bytes_per_sec", value)

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @max_snapshot_bytes_per_sec.setter
    def max_snapshot_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_snapshot_bytes_per_sec", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryHdfsArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 uri: pulumi.Input[str],
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 load_defaults: Optional[pulumi.Input[bool]] = None,
                 max_restore_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 max_snapshot_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: The file path within the filesystem where data is stored/loaded.
        :param pulumi.Input[str] uri: The uri address for hdfs. ex: "hdfs://\n\n:\n\n/".
        :param pulumi.Input[str] chunk_size: Maximum size of files in snapshots.
        :param pulumi.Input[bool] compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param pulumi.Input[bool] load_defaults: Whether to load the default Hadoop configuration or not.
        :param pulumi.Input[str] max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param pulumi.Input[str] max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param pulumi.Input[bool] readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "uri", uri)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if load_defaults is not None:
            pulumi.set(__self__, "load_defaults", load_defaults)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The file path within the filesystem where data is stored/loaded.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        The uri address for hdfs. ex: "hdfs://\n\n:\n\n/".
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="loadDefaults")
    def load_defaults(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to load the default Hadoop configuration or not.
        """
        return pulumi.get(self, "load_defaults")

    @load_defaults.setter
    def load_defaults(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "load_defaults", value)

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @max_restore_bytes_per_sec.setter
    def max_restore_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_restore_bytes_per_sec", value)

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @max_snapshot_bytes_per_sec.setter
    def max_snapshot_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_snapshot_bytes_per_sec", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryS3Args:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 base_path: Optional[pulumi.Input[str]] = None,
                 buffer_size: Optional[pulumi.Input[str]] = None,
                 canned_acl: Optional[pulumi.Input[str]] = None,
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 client: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 max_restore_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 max_snapshot_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None,
                 server_side_encryption: Optional[pulumi.Input[bool]] = None,
                 storage_class: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: Name of the S3 bucket to use for snapshots.
        :param pulumi.Input[str] base_path: Specifies the path to the repository data within its bucket.
        :param pulumi.Input[str] buffer_size: Minimum threshold below which the chunk is uploaded using a single request.
        :param pulumi.Input[str] canned_acl: The S3 repository supports all S3 canned ACLs.
        :param pulumi.Input[str] chunk_size: Maximum size of files in snapshots.
        :param pulumi.Input[str] client: The name of the S3 client to use to connect to S3.
        :param pulumi.Input[bool] compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param pulumi.Input[str] max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param pulumi.Input[str] max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param pulumi.Input[bool] readonly: If true, the repository is read-only.
        :param pulumi.Input[bool] server_side_encryption: When true, files are encrypted server-side using AES-256 algorithm.
        :param pulumi.Input[str] storage_class: Sets the S3 storage class for objects stored in the snapshot repository.
        """
        pulumi.set(__self__, "bucket", bucket)
        if base_path is not None:
            pulumi.set(__self__, "base_path", base_path)
        if buffer_size is not None:
            pulumi.set(__self__, "buffer_size", buffer_size)
        if canned_acl is not None:
            pulumi.set(__self__, "canned_acl", canned_acl)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if client is not None:
            pulumi.set(__self__, "client", client)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)
        if server_side_encryption is not None:
            pulumi.set(__self__, "server_side_encryption", server_side_encryption)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        Name of the S3 bucket to use for snapshots.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="basePath")
    def base_path(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the path to the repository data within its bucket.
        """
        return pulumi.get(self, "base_path")

    @base_path.setter
    def base_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_path", value)

    @property
    @pulumi.getter(name="bufferSize")
    def buffer_size(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum threshold below which the chunk is uploaded using a single request.
        """
        return pulumi.get(self, "buffer_size")

    @buffer_size.setter
    def buffer_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "buffer_size", value)

    @property
    @pulumi.getter(name="cannedAcl")
    def canned_acl(self) -> Optional[pulumi.Input[str]]:
        """
        The S3 repository supports all S3 canned ACLs.
        """
        return pulumi.get(self, "canned_acl")

    @canned_acl.setter
    def canned_acl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "canned_acl", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def client(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the S3 client to use to connect to S3.
        """
        return pulumi.get(self, "client")

    @client.setter
    def client(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @max_restore_bytes_per_sec.setter
    def max_restore_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_restore_bytes_per_sec", value)

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @max_snapshot_bytes_per_sec.setter
    def max_snapshot_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_snapshot_bytes_per_sec", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)

    @property
    @pulumi.getter(name="serverSideEncryption")
    def server_side_encryption(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, files are encrypted server-side using AES-256 algorithm.
        """
        return pulumi.get(self, "server_side_encryption")

    @server_side_encryption.setter
    def server_side_encryption(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_side_encryption", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[str]]:
        """
        Sets the S3 storage class for objects stored in the snapshot repository.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class ElasticsearchSnapshotRepositoryUrlArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str],
                 chunk_size: Optional[pulumi.Input[str]] = None,
                 compress: Optional[pulumi.Input[bool]] = None,
                 http_max_retries: Optional[pulumi.Input[int]] = None,
                 http_socket_timeout: Optional[pulumi.Input[str]] = None,
                 max_number_of_snapshots: Optional[pulumi.Input[int]] = None,
                 max_restore_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 max_snapshot_bytes_per_sec: Optional[pulumi.Input[str]] = None,
                 readonly: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] url: URL location of the root of the shared filesystem repository.
        :param pulumi.Input[str] chunk_size: Maximum size of files in snapshots.
        :param pulumi.Input[bool] compress: If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        :param pulumi.Input[int] http_max_retries: Maximum number of retries for http and https URLs.
        :param pulumi.Input[str] http_socket_timeout: Maximum wait time for data transfers over a connection.
        :param pulumi.Input[int] max_number_of_snapshots: Maximum number of snapshots the repository can contain.
        :param pulumi.Input[str] max_restore_bytes_per_sec: Maximum snapshot restore rate per node.
        :param pulumi.Input[str] max_snapshot_bytes_per_sec: Maximum snapshot creation rate per node.
        :param pulumi.Input[bool] readonly: If true, the repository is read-only.
        """
        pulumi.set(__self__, "url", url)
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if compress is not None:
            pulumi.set(__self__, "compress", compress)
        if http_max_retries is not None:
            pulumi.set(__self__, "http_max_retries", http_max_retries)
        if http_socket_timeout is not None:
            pulumi.set(__self__, "http_socket_timeout", http_socket_timeout)
        if max_number_of_snapshots is not None:
            pulumi.set(__self__, "max_number_of_snapshots", max_number_of_snapshots)
        if max_restore_bytes_per_sec is not None:
            pulumi.set(__self__, "max_restore_bytes_per_sec", max_restore_bytes_per_sec)
        if max_snapshot_bytes_per_sec is not None:
            pulumi.set(__self__, "max_snapshot_bytes_per_sec", max_snapshot_bytes_per_sec)
        if readonly is not None:
            pulumi.set(__self__, "readonly", readonly)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        URL location of the root of the shared filesystem repository.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum size of files in snapshots.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter
    def compress(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, metadata files, such as index mappings and settings, are compressed in snapshots.
        """
        return pulumi.get(self, "compress")

    @compress.setter
    def compress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "compress", value)

    @property
    @pulumi.getter(name="httpMaxRetries")
    def http_max_retries(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of retries for http and https URLs.
        """
        return pulumi.get(self, "http_max_retries")

    @http_max_retries.setter
    def http_max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_max_retries", value)

    @property
    @pulumi.getter(name="httpSocketTimeout")
    def http_socket_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum wait time for data transfers over a connection.
        """
        return pulumi.get(self, "http_socket_timeout")

    @http_socket_timeout.setter
    def http_socket_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_socket_timeout", value)

    @property
    @pulumi.getter(name="maxNumberOfSnapshots")
    def max_number_of_snapshots(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of snapshots the repository can contain.
        """
        return pulumi.get(self, "max_number_of_snapshots")

    @max_number_of_snapshots.setter
    def max_number_of_snapshots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_number_of_snapshots", value)

    @property
    @pulumi.getter(name="maxRestoreBytesPerSec")
    def max_restore_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot restore rate per node.
        """
        return pulumi.get(self, "max_restore_bytes_per_sec")

    @max_restore_bytes_per_sec.setter
    def max_restore_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_restore_bytes_per_sec", value)

    @property
    @pulumi.getter(name="maxSnapshotBytesPerSec")
    def max_snapshot_bytes_per_sec(self) -> Optional[pulumi.Input[str]]:
        """
        Maximum snapshot creation rate per node.
        """
        return pulumi.get(self, "max_snapshot_bytes_per_sec")

    @max_snapshot_bytes_per_sec.setter
    def max_snapshot_bytes_per_sec(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_snapshot_bytes_per_sec", value)

    @property
    @pulumi.getter
    def readonly(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, the repository is read-only.
        """
        return pulumi.get(self, "readonly")

    @readonly.setter
    def readonly(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "readonly", value)


@pulumi.input_type
class ProviderElasticsearchArgs:
    def __init__(__self__, *,
                 ca_file: Optional[pulumi.Input[str]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 insecure: Optional[pulumi.Input[bool]] = None,
                 password: Optional[pulumi.Input[str]] = None,
                 username: Optional[pulumi.Input[str]] = None):
        if ca_file is not None:
            pulumi.set(__self__, "ca_file", ca_file)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if insecure is not None:
            pulumi.set(__self__, "insecure", insecure)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter(name="caFile")
    def ca_file(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_file")

    @ca_file.setter
    def ca_file(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_file", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter
    def insecure(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "insecure")

    @insecure.setter
    def insecure(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "username", value)


